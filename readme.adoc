= Camunda Demo Starter

== Quick Start

Follow the steps below to use Docker Compose to quickly start a fully functioning Camunda environment (either version 7 or version 8).

* Create a new directory named `camunda-demo`

 mkdir camunda-demo

* Change into this new directory. (All steps below assume you are in this new `camunda-demo` directory)

 cd camunda-demo

* Now jump to either <<camunda_8_quick_start, Camunda 8>> or <<camunda_7_quick_start, Camunda 7>> sections below.

=== Camunda 8 [[camunda_8_quick_start]]

* Clone the `Camunda Platform` project into your local `camunda-demo` directory.

 git clone https://github.com/camunda/camunda-platform.git

* Clone this project (the `camunda-demo-starter` project) into your local `camunda-demo` directory.

 git clone https://github.com/camunda-consulting/camunda-demo-starter.git

* Start a Camunda 8 environment from your `camunda-demo` directory

 cd camunda-demo
 docker-compose -f ./camunda-demo-starter/docker-compose.postgres.yml \
                -f ./camunda-demo-starter/docker-compose.data-api.yml \
                -f ./camunda-demo-starter/docker-compose.reactjs.yml \
                -f ./camunda-demo-starter/docker-compose.smtp.yml \
                -f ./camunda-platform/docker-compose-core.yaml \
                -f ./camunda-demo-starter/docker-compose.c8.yml \
                up -d

* After the environment starts up, access each of the components like so:
** camunda-react: http://localhost:3000
** operate: http://localhost:8081
*** username/password: demo/demo
** tasklist: http://localhost:8082
** TODO: optimize isn't currently included .. should we include it as part of default? optimize: http://localhost:808?
** c8-client: http://localhost:9012 (TODO: verify this)
** data-api: http://localhost:9000 (TODO: verify this)
** camunda-postgres: localhost:5432 (TODO: verify this)
*** username/password: camunda/camunda
** zeebe: localhost: 26500

=== Camunda 7 [[camunda_7_quick_start]]

* Clone this project (the `camunda-demo-starter` project) into your local `camunda-demo` directory

 git clone https://github.com/camunda-consulting/camunda-demo-starter.git

* Start a Camunda 7 environment

 docker-compose  -f ./camunda-demo-starter/docker-compose.postgres.yml
                 -f ./camunda-demo-starter/docker-compose.data-api.yml
                 -f ./camunda-demo-starter/docker-compose.smtp.yml
                 -f ./camunda-demo-starter/docker-compose.c7.yml
                 up -d

* After the environment starts up, access each of the components like so:
** camunda-react: http://localhost:3000
** operate: http://localhost:8082 (TODO: verify this)
*** username/password: demo/demo
** data-api: http://localhost:9000 (TODO: verify this)
** optimize: http://localhost:8082 (TODO: verify this)
** tasklist: http://localhost:8081 (TODO: verify this)
** camunda-postgres: localhost:5432
*** username/password: camunda/camunda

== Presentation Slide Template

https://docs.google.com/presentation/d/1fI7mdW_Q6yEiM0H01b58aQVa74YkTnYj/[Proof of Technology Google Slides Template]

== Components

The Quick Start steps above include the most commonly used components for demos.

In addition to the default services shown in the "Quick Start" steps above, there are also additional components, such as `camunda-kafka` and/or `camunda-ldap`.

All available components are described in more detail below.

Each component is managed in its own GitHub repository. Here are some suggestions when customizing components:

* Read the documentation on each project below. Fork the project from github into a new repository and checkout into a local project directory.
* Place an enterprise `license.txt` file into the local directory.
* Get enterprise credentials for maven/nexus/jfrog and place them in the `settings.xml`. Copy the `settings.xml` file into your local directory
* TODO: more details on how to create settings.xml file? NOTE: To get credentials you need to create an API key.
* Make your changes and work in your fork.
* TODO: more details on how to start the projects in "development" mode using spring boot profiles
* If you have a contribution that isn't specific to a customer create a pull request.

=== camunda-data-api

TODO: link to github and short description

=== camunda-platform-7-spring-boot

TODO: link to github and short description

=== camunda-7-spring-boot-client

TODO: link to github and short description

=== camunda-8-spring-boot-client

TODO: link to github and short description

=== camunda-react

TODO: link to github and short description

=== camunda-servlet-project

TODO: link to github and short description

=== camunda-tomcat-docker

TODO: link to github and short description

=== camunda-kafka

TODO: link to github and short description

=== camunda-ldap

TODO: link to github and short description

=== camunda-postman

TODO: link to github and short description

=== camunda-dmn-worker

TODO: link to github and short description

=== Authentication and Authorization

TODO: describe using identity for securing the data api and rest apis?

== Documentation IN PROGRESS

TODO: MOVE all the following documentation into appropriate, individual project README's

TIP: Have a look at the docker-compose.<<>>.yml to see the other services you can run and build.

==== Camunda Platform

 Put the license.txt file with your license in the home directory of the project

IMPORTANT: Each project `camunda-data-api-demo`, `camunda-platform-spring-boot`, `camunda-reactjs-demo` each must have a settings.xml with the credentials.


*Build the default apps*

- camunda-platform - localhost:8080
- data-api - localhost:9000
- demo-reactjs - localhost:3000
- camunda-postgres - localhost:5432

```
docker-compose -f docker-compose.c7.yml  -f docker-compose.postgres.yml -f docker-compose.c7-optimize.yml -f docker-compose.data-api.yml  -f docker-compose.reactjs.yml up -d --build camunda-platform optimize data-api reactjs-demo
```

NOTE: It's possible to build and restart only a specific apps to speed up development.

```
 docker-compose -f docker-compose.<<>>.yml up -d --build <service-name>
```

TIP: Have a look at the docker-compose.<<>>.yml to see the other services you can run and build.

====

#### Camunda Platform
====
Camunda Platform in the context of this project is the Camunda Platform as custom embedded Spring-Boot app.

NOTE: Camunda Platform can be run independently of the the other apps. It can also be run in different flavors such as Tomcat with servlet-project. See the docker-compose files in project home.

For convenience there are several prebuilt or preconfigured components to make the poc's and custom demos easier and faster to do. Additionally a standardized file structure is utilized.

- BPMN Workflow Models are in `camunda-platform-spring-boot/src/main/resources/processes/sample.bpmn`

- Reusable delegates are in `camunda-platform-spring-boot/src/main/java/com/camunda/poc/starter/bpm`

- Integrations are in `camunda-platform-spring-boot/src/main/java/com/camunda/poc/starter/integration`

- Engine plugins `camunda-platform-spring-boot/src/main/java/com/camunda/poc/starter/plugin`

- Eventing and messaging `camunda-platform-spring-boot/src/main/java/com/camunda/poc/starter/pubsub`

- Specific technical use cases and integrations  `camunda-platform-spring-boot/src/main/java/com/camunda/poc/starter/usecase`

====

//===== CLI
//NOTE: You can enable spring-dev-tools to build front and back-end component in dev mode providing faster restarts and live-reload.
//
//run the app in dev mode by uncommenting spring-dev-tools in pom.xml
//
//WARNING: spring-dev-tools affects the way Camunda serializes objects into process vars and will cause serialization errors in some cases. So it is commented out in pom.xml by default.
//
//run the following with the appropriate profiles
//
//    mvn spring-boot:run -Dspring.profiles.active=poc,email,cors
//
//---




#### Running the data-api server for Dev
====
```
 docker-compose -f docker-compose.dev.yml up -d --build data-api
```
====

#### Modifying and developing the data-api server
====
You need to change this project when you want a new data api to access from your UI or Camunda Worflow. It is a quick way to mock and spin up an api to show a prospect how we can integrate with data and potentially their data model.

Spring, JPA, HATEOS, Lombok are used to quickly build API's that are standardized and reusable.

See the examples in the `src/main/java/com/camunda/poc/starter/data`

You need to create a `config`, `entity` and `Repository` to expose a new API.

NOTE: The ReactJS Demo is configured to use the exposed Data API relatively easily and Camunda project has some Delegate examples.

====



//====
//NOTE: You can enable spring-dev-tools to build front and back-end component in dev mode providing faster restarts and live-reload.
//
//run the app in dev mode by uncommenting spring-dev-tools in pom.xml
//
//WARNING: spring-dev-tools affects the way Camunda serializes objects into process vars and will cause serialization errors in some cases. So it is commented out in pom.xml by default.
//
//run the following with the appropriate profiles
//
//    mvn spring-boot:run -Dspring.profiles.active=poc,email,cors
//====

//#### Kafka

//===== CLI

//==== Using spring-boot profiles
//====
//Start Camunda with Basic Auth on REST api and Authorizations on foe webapps
//
// -Dspring.profiles.active=cors,pubsub,kafka,email,prod,poc,auth,auth-rest"
//
//====


### Project Structure

The project has an opinionated project structure.

#### Conventions for reusable or general usecase JAVA code

such as auth or securtity or email etc... belong in the appropriate package under the **_starter_** package.

For example for keycloak authentication

```java
src/main/java/com.camunda.poc.starter.auth.keycloak
```

#### **Conventions for JAVA code specific to a use case**

there is **_usecase_** package. Create a new package under this package.

```java
 src/main/java/com.camunda.poc.starter.usecase.your-use-case

```

See the project for examples

#### **Conventions for non-code artifacts**

BPMN files live in ```src/main/resources/processes``` and use a prefix for general and specific use-case `` usecase-usecase-example.bpmn ``

Example general use -case `` event-integration-example.bpmn ``

Example specific use-case `` renewal-process-example.bpmn ``



#### Conventions for JS code

JS code for custom ReactJS UI lives in
`` src/main/js/reactjs/<use-case> ``


## Setting up the App for your use-case

### Profiles

The application can have many different configurations depending on where it is deployed and what the goal of the deployment may be. Profiles can be set standalone or in conjunction with other profiles to create the configuration needed for the app. Each profile will enable specific functionality. Profiles are set and enabled by postfix on a .properties file and/or a @Profile annotation on the specific code.

The application utilizes Spring profiles to manage configurations and environments. See more here <https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html>

The configurations are related to the profiles specified in the Profile Examples section. Additionally there is a default configuration that is not specific to an environment. The application uses properties to specify a configuration.

These configurations are grouped into files with the following naming pattern. `application-{profile}.properties` or just `application.properties` for the default configuration.

Profiles can be specified at the command line when the application starts. The notation is as follows. `-Dspring.profiles.active=dev,renewals`

Or you can use the application.properties file to specify the profile.

`spring.profiles.active: dev,renewals`

**Note:** Properties specified at the command line override properties in the .properties files.

**Note:** the global configurations are in the application.yml file in the resources directory.

**Profile Examples**

- Development `application-dev.properties` `-Dspring.profiles.active=dev`

- Authentication and Authorization `applicaiton-auth.yaml`

- Email `application-email.properites`

- Integration `application-integration.properties`

- Security `applicaiton-secutrity.properits`

- Renewals Use Case `application-renewals.properties`
- Production `application-prod.properties`

#### Custom Application Configuration through code

The ****AppConfigProperties.java**** class makes the configs code-able

Adding configs to this class allows you to customize the configurations. This class will pickup properties from a .properties/yaml and allow you to inject this class into other classes as needed.

**_more to come ..._**

### Externalizing Configuration

All the properties in the .properties files can be externalized.

Look at the **_application-prod.properties_** files for examples of utilizing environment variables with the app. This is particularly useful if your running in serverless environment and you cannot store property values in your code repo.



## Running the App

The application can be packaged as a jar for easy deployment to serverless environment. Example of starting with profiles also externalizing the Sendgrid api key.

[source,bash]
----
mvn clean install -DskipTests
java -Dspring.profiles.active=prod,renewals,email -DSENDGRID_API_KEY=<someapikey> -jar target/camunda-poc-starter.jar
----

or for development run

[source,bash]
----
mvn clean spring-boot:run -Dspring-boot.run.profiles=dev,<other profile>
----

**Profiles** can be specified at the command line when the application starts. The notation is as follows.

[source,bash]
----
-Dspring.profiles.active=<profile>,<profile>
----

Or you can use the application.properties file to specify the profile.

[source,yaml]
----
spring.profiles.active: <profile>,<profile>
----


## Deploying the app

### Docker and Docker-Compose

Services are configure in the docker-compose.yaml to run the app in docker with a default network.

1. Uncomment the appropriate services for your application and profiles in the docker-compose.yaml located in the docker-compose directory.
2. Make sure to build the spring-boot app
3. run docker-compose up from the docker-compose directory

### Heroku

Deploying to heroku requires the use of GIT and the Heroku CLI. See following for more on deploying spring applications.

- <https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku>
- <https://devcenter.heroku.com/articles/procfile>
- <https://devcenter.heroku.com/articles/connecting-to-relational-databases-on-heroku-with-java#using-the-jdbc_database_url>

Sometimes it's necessary to reset the DB. See following.

- <https://devcenter.heroku.com/articles/heroku-postgresql#pg-reset>

#### Environment configs

There are a few configurations you must add to Heroku for the app to work correctly

- JDBC_DATABASE_URL - This config is added for you. You wont see it in the Heroku dashboard. Run the following command to confirm this is set.

----
heroku run echo \$JDBC_DATABASE_URL
----

- Externalize environment specific configurations that should not be stored in .properties files. E.g. mail server password

- Use environment configurations the app will use based off the profiles application-
----
<profile>.properties </profile>
----


TIP: **Procfile Example** This file is used to configure the HEROKU service to run the app. Spring profiles can be used along with the Procfile to configure the app. See profiles above for details on what each profile does. Keep in mind this is based on the Procfile and will only take affect in an environment that uses the procfile like Heroku.

----
web: java -Dserver.port=$PORT -Dspring.profiles.active=$PROFILE,$ENVIRONMENT -jar target/camunda-poc-starter-app.jar
----

In the heroku configuration panel we can feed in the parameters to our startup command and the app configs in the .properties files.

â€‹
////
## TODO

- Use the Camunda REST api's from the React app
- **Add middle-ware layer to aggregate calls to the REST API e.g. GraphQL**

  - Implementation is to just add new spring controllers that call the camunda rest API's

- Add keycloak and route API calls through security

- **Create architecture diagrams to exemplify architecture usecases based on biz usecases**

- Externalize email template

- **Improve the style of the UI**

////